# Глоссарий, синонимы:
- Application Under Test (AUT), веб-приложение, приложение, продукт
- Page Object или Page Object models, POM, PO
- Паттерны проектирования, шаблоны проектирования

# Введение
## Everything is a code. No Excuses for Autotests.

В современной разработке приложений внесение изменений является непрерывным процессом. Невозможно оценить качество этих изменений без использования автоматизированных тестов. Это ведет к тому, что изменения постоянно вносятся и в код тестов. Из-за быстрого темпа работы, под автоматизацией уже подразумеваются не только сами тестовые сценарии, но и их запуск и результаты (ведь никому не хочется ждать, пока тестировщик запустит автотесты, правда?).

Оптимально для такого процесса понимать, что код автотестов это тоже код продукта. Это подразумевает использование тех же методов, как при разработке продуктового кода: применение линтеров, участие в процессе ревью кода и так далее. Также важно уделить внимание метрикам, - в первую очередь снижении стоимости поддержки кода автотестов.

Когда мы говорим про быстроту написания кода и про стоимость сопровождения - для нас незаменимо знание о паттернах проектирования. 

Наш курс посвящен браузерным тестам, симулирующим пользовательские действия. Стоит заметить, что нередко браузерные тесты считаются нестабильными. Важно понимать, что широко используемые инструменты тестирования, такие как Selenium или WebDriver, это качественный результат труда коммьюнити и при правильной настройке и использовании не добавляют проблем тестам. Зато знание паттернов позволяет писать более стабильные тесты.

Итак, ниже мы рассмотрим один из применимых к браузерным тестам паттернов - Page Object или Page object models.

# Теория

Page Object вы можете встретить и в легаси проектах, и применить его в новых проектах. Проект Selenium прямо указывает на него как на одну из лучших тестовых практик в своей wiki - https://www.selenium.dev/documentation/test_practices/encouraged/page_object_models/.

Что такое Page Object кратко? Это шаблон проектирования, при котором страница веб-приложения или её часть представляется в виде отдельного объекта, инкапсулирующего логику и элементы интерфейса и предоставляющего методы для работы с этим объектом в терминах пользовательского взаимодействия.

Составим краткий чек-лист свойств Page Object, чтобы применить его на практике:
- каждая страница (или объект на ней) - это отдельный класс
- названия методов отображают действия пользователя
- методы возвращают другие PO или базовые типы
- не отображаем внутренние механизмы страницы
- PO не обязаны представлять всю страницу
- PO не делают проверок, их делают тесты


# Практика

PO мало зависит от языка программирования или фреймворка автоматизации, поэтому мы рассмотрим его на примере Python и Selenium.

Давайте попробуем рассмотреть на примере пользовательского сценария.
У нас есть учебный онлайн магазин http://pizzeria.skillbox.cc/ - что может быть важнее для бизнеса, чем переход из корзины в чекаут? 
Проверим навигацию:
- пользователь находится на странице корзины
- нажимает кнопку "Перейти к оплате"
- попадает на страницу чекаута, где он может ввести данные доставки и оплатить заказ

```python
def test_checkout_button(driver):
    # arrange
    driver.get('http://pizzeria.skillbox.cc/cart/')
    button = driver.find_element(By.CLASS_NAME, "checkout-button.button.alt.wc-forward")

    # act
    button.click()

    # assert
    assert driver.current_url == 'http://pizzeria.skillbox.cc/checkout/'
```

Заметно, что логика теста не отделена от локаторов объектов на странице. Если мы захотим написать больше тестов с нашей кнопкой, локатор придётся продублировать. С этим можно попробовать бороться при помощи помещения локаторов в импортируемые модули, но это не поможет избавиться от проблемы читаемости. 
Если мы буквально попробуем прочитать этот код, то станет заметно, что он мало похож на наш сценарий. В нем нет ни слова про действие покупателя и приходится догадываться, на какой странице мы находимся.

Попробуем применить тут PO, раз у нас есть чек-лист.
Отдельных страниц у нас не одна, а две - страница корзины и страница чекаута, значит и классов должно быть два:

```python
class Cart(object):
    def __init__(self, driver):
        self.driver = driver
        self.checkout_button = driver.find_element(By.CLASS_NAME, "checkout-button.button.alt.wc-forward")
 
    def click_checkout_button(self):
        self.checkout_button.click()
        return Checkout(self.driver)

class Checkout(object):
    def __init__(self, driver):
        self.driver = driver
```

Пройдемся по нашему чек-листу, и увидим, что предложенные два класса покрывают все требования, описанные нами.

Осталось изменить наш тест:
```python
def test_checkout_button(driver):
    # arrange
    driver.get('http://pizzeria.skillbox.cc/cart/')
    # act
    Cart(driver).click_checkout_button()
    # assert
    assert driver.current_url == 'http://pizzeria.skillbox.cc/checkout/'
```

Сценарий уже читается лучше - нам понятна основная страница и действие пользователя.
Только вот кода стало заметно больше! Хотя это и не относится напрямую к PO, но стоит предусмотреть простую раскладку наших классов и тестов в проекте, например:

```
tests/
├── pages/
│   ├── cart.py
│   ├── checkout.py
│   └── ...
├── test_cases/
│   ├── test_cart.py
│   └── ...
...
```

В описаниях шаблона мы не видим четкой границы, что представляют собой методы PO. Они могут быть атомарными действиями - как клик по кнопке или ввод текста в поле, но могут быть и более комплексными действиями.
Например, в предложенном классе Checkout мы можем добавить метод is_opened и использовать в тестах его:

``` python
class Checkout(object):
    def __init__(self, driver):
        self.driver = driver

    def is_opened(self):
        return '/checkout/' in self.driver.current_url
...

def test_checkout_button(driver):
    # arrange
    driver.get('http://pizzeria.skillbox.cc/cart/')
    # act
    checkout = Cart(driver).click_checkout_button()
    # assert
    assert checkout.is_opened()
```

Объект Checkout не занимается в этом примере проверками вместо тестов, но предоставляет им удобный метод для этих проверок.
Полные примеры файлов с тестами вы сможете найти в учебны материалах


# Итоги

Правильно рассматривать автотесты как часть кода проекта. Для браузерных e2e автотестов в этом случае применим паттерн Page Object. 
Помещая описание локаторов в объекты и создавая в этих объектах методы взаимодействия со страницей мы можем писать тесты повторно используя код и разделять механизмы взаимодействия со страницей от пользовательских действий в тестовом сценарии. 
Благодаря простоте паттерн применим для разных языков программирования и тестовых фреймворков.

Но также паттерн PO не абсолютно универсален - его применение часто приводит к плохим результатам на страницах SPA, страницах с динамическим контентом. Порождаемые им классы могут быть велики (десятки или больше методов и локаторов), следовательно трудны в поддержке.

Существуют и другие патерны, мы продолжим знакомиться с ними далее на нашем курсе.
// примеры из курса
- Fluent Interface
- Screenplay Pattern
- etc.

# Extra

Дополнительных материалов про Page Object очень много, я советую познакомиться с некоторыми из них,
- блог Мартина Фаулера https://martinfowler.com/bliki/PageObject.html
- блог инженеров google, посвященному тестированию https://testing.googleblog.com/2009/04/survival-techniques-for-acceptance.html